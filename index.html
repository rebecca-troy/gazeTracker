<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Improved Gaze Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1); /* mirror webcam */
      z-index: 1;
    }
    #gaze-dot {
      position: absolute;
      width: 20px;
      height: 20px;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 100; /* Ensure it's on top */
    }
    #debug {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background: black;
      color: white;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
  <video class="input_video" autoplay muted playsinline></video>
  <canvas class="output_canvas"></canvas>
  <div id="debug">Initializing...</div>
  <div id="gaze-dot"></div>

  <script>
    const video = document.querySelector('.input_video');
    const canvas = document.querySelector('.output_canvas');
    const ctx = canvas.getContext('2d');
    const debug = document.getElementById('debug');
    const gazeDot = document.getElementById('gaze-dot');

    let modelReady = false;
    let calibrationPoints = [];
    let currentPointIndex = 0;
    let sampleData = [];

    // Variables for smoothing gaze prediction
    let smoothedX = window.innerWidth / 2;
    let smoothedY = window.innerHeight / 2;
    const smoothingFactor = 0.2; // Adjust this factor for more/less smoothing

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    faceMesh.onResults(onResults);

    const camera = new Camera(video, {
      onFrame: async () => await faceMesh.send({ image: video }),
      width: 640,
      height: 480
    });
    camera.start();

    // Define the positions of calibration points
    function setupCalibrationPoints() {
      const rows = 3;
      const cols = 3;
      const spacingX = window.innerWidth / (cols + 1);
      const spacingY = window.innerHeight / (rows + 1);

      calibrationPoints = [];
      for (let row = 1; row <= rows; row++) {
        for (let col = 1; col <= cols; col++) {
          const x = spacingX * col;
          const y = spacingY * row;
          calibrationPoints.push({ x, y });
        }
      }
    }

    function drawLandmark(pt, color = 'cyan', size = 4) {
      ctx.beginPath();
      ctx.arc(pt.x * canvas.width, pt.y * canvas.height, size, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function onResults(results) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (!results.multiFaceLandmarks.length) {
        debug.textContent = 'No face detected';
        return;
      }

      const landmarks = results.multiFaceLandmarks[0];

      const iris = landmarks[468]; // left eye center
      const nose = landmarks[1]; // nose position

      drawLandmark(iris, 'red');
      drawLandmark(nose, 'yellow');

      // Calibration phase: Collecting gaze data
      if (!modelReady) {
        const point = calibrationPoints[currentPointIndex];
        gazeDot.style.left = `${point.x}px`;
        gazeDot.style.top = `${point.y}px`;

        const features = extractFeatures(iris, nose);
        sampleData.push({ features, target: point });

        // When we reach 30 samples for a calibration point, move to the next point
        if (sampleData.length % 30 === 0) {
          currentPointIndex++;
          if (currentPointIndex >= calibrationPoints.length) {
            trainModel();
            modelReady = true;
            gazeDot.remove();
            debug.textContent = "âœ… Calibration complete. Tracking gaze...";
          }
        } else {
          debug.textContent = `Calibrating... (${sampleData.length} samples collected)`;
        }
      } else {
        // Predict gaze location after calibration
        const features = extractFeatures(iris, nose);
        const predictedPoint = predictGaze(features);
        drawGazeDot(predictedPoint.x, predictedPoint.y);
      }
    }

    function extractFeatures(iris, nose) {
      return [
        iris.x - nose.x, // difference in X axis between iris and nose
        iris.y - nose.y  // difference in Y axis between iris and nose
      ];
    }

    function predictGaze(features) {
      // A simple nearest-neighbor-like prediction for demonstration
      const minDist = Math.min(...sampleData.map(d => {
        return Math.sqrt(Math.pow(d.features[0] - features[0], 2) + Math.pow(d.features[1] - features[1], 2));
      }));
      const bestMatch = sampleData.find(d => {
        const dist = Math.sqrt(Math.pow(d.features[0] - features[0], 2) + Math.pow(d.features[1] - features[1], 2));
        return dist === minDist;
      });
      return bestMatch.target || { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }

    function trainModel() {
      // Model is trained by mapping the iris-nose features to screen coordinates (gaze points)
      debug.textContent = "Training gaze model...";
    }

    function drawGazeDot(x, y) {
      // Apply smoothing to the gaze point
      smoothedX = smoothedX * (1 - smoothingFactor) + x * smoothingFactor;
      smoothedY = smoothedY * (1 - smoothing Factor) + y * smoothingFactor;

      // Update the gaze dot's position
      gazeDot.style.left = `${smoothedX}px`;
      gazeDot.style.top = `${smoothedY}px`;

      // Debugging text to track gaze dot position
      debug.textContent = `Gaze dot at: ${smoothedX.toFixed(2)}, ${smoothedY.toFixed(2)}`;
    }

    setupCalibrationPoints();
  </script>
</body>
</html>
